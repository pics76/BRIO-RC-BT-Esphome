// color_map.h
#pragma once
#include <stdint.h>

struct ColorMap {
  uint8_t code;
  const char* sensor_name;
  const uint8_t *values; // pointeur vers tableau
  size_t values_len;     // longueur du tableau
};

// Tableaux de données
static const uint8_t white_vals[]     = {0x7b,0x22,0x70,0x72,0x6f,0x6a,0x65,0x63,0x74,0x65,0x75,0x72,0x22,0x3a,0x31,0x7d};
static const uint8_t blue_vals[]      = {0x7b,0x22,0x70,0x72,0x6f,0x6a,0x65,0x63,0x74,0x65,0x75,0x72,0x22,0x3a,0x32,0x7d};
static const uint8_t lagoon_vals[]    = {0x7b,0x22,0x70,0x72,0x6f,0x6a,0x65,0x63,0x74,0x65,0x75,0x72,0x22,0x3a,0x33,0x7d};
static const uint8_t cyan_vals[]      = {0x7b,0x22,0x70,0x72,0x6f,0x6a,0x65,0x63,0x74,0x65,0x75,0x72,0x22,0x3a,0x34,0x7d};
static const uint8_t purple_vals[]    = {0x7b,0x22,0x70,0x72,0x6f,0x6a,0x65,0x63,0x74,0x65,0x75,0x72,0x22,0x3a,0x35,0x7d};
static const uint8_t magenta_vals[]   = {0x7b,0x22,0x70,0x72,0x6f,0x6a,0x65,0x63,0x74,0x65,0x75,0x72,0x22,0x3a,0x36,0x7d};
static const uint8_t pink_vals[]      = {0x7b,0x22,0x70,0x72,0x6f,0x6a,0x65,0x63,0x74,0x65,0x75,0x72,0x22,0x3a,0x37,0x7d};
static const uint8_t red_vals[]       = {0x7b,0x22,0x70,0x72,0x6f,0x6a,0x65,0x63,0x74,0x65,0x75,0x72,0x22,0x3a,0x38,0x7d};
static const uint8_t orange_vals[]    = {0x7b,0x22,0x70,0x72,0x6f,0x6a,0x65,0x63,0x74,0x65,0x75,0x72,0x22,0x3a,0x39,0x7d};
static const uint8_t green_vals[]     = {0x7b,0x22,0x70,0x72,0x6f,0x6a,0x65,0x63,0x74,0x65,0x75,0x72,0x22,0x3a,0x31,0x30,0x7d};
static const uint8_t fav_vals[]       = {0x7b,0x22,0x70,0x72,0x6f,0x6a,0x65,0x63,0x74,0x65,0x75,0x72,0x22,0x3a,0x31,0x31,0x7d};
static const uint8_t gradient_vals[]  = {0x7b,0x22,0x70,0x72,0x6f,0x6a,0x65,0x63,0x74,0x65,0x75,0x72,0x22,0x3a,0x31,0x36,0x7d};
static const uint8_t rainbow_vals[]   = {0x7b,0x22,0x70,0x72,0x6f,0x6a,0x65,0x63,0x74,0x65,0x75,0x72,0x22,0x3a,0x31,0x37,0x7d};
static const uint8_t parade_vals[]    = {0x7b,0x22,0x70,0x72,0x6f,0x6a,0x65,0x63,0x74,0x65,0x75,0x72,0x22,0x3a,0x31,0x38,0x7d};
static const uint8_t techno_vals[]    = {0x7b,0x22,0x70,0x72,0x6f,0x6a,0x65,0x63,0x74,0x65,0x75,0x72,0x22,0x3a,0x31,0x39,0x7d};
static const uint8_t horizon_vals[]   = {0x7b,0x22,0x70,0x72,0x6f,0x6a,0x65,0x63,0x74,0x65,0x75,0x72,0x22,0x3a,0x32,0x30,0x7d};
static const uint8_t hazard_vals[]    = {0x7b,0x22,0x70,0x72,0x6f,0x6a,0x65,0x63,0x74,0x65,0x75,0x72,0x22,0x3a,0x32,0x31,0x7d};
static const uint8_t magical_vals[]   = {0x7b,0x22,0x70,0x72,0x6f,0x6a,0x65,0x63,0x74,0x65,0x75,0x72,0x22,0x3a,0x32,0x32,0x7d};

// Table de correspondance
static const ColorMap color_map[] = {
  {0x01, "Blanc",      white_vals,  sizeof(white_vals)},
  {0x02, "Bleu",       blue_vals,  sizeof(blue_vals)},
  {0x03, "Lagon",      lagoon_vals,  sizeof(lagoon_vals)},
  {0x04, "Cyan",       cyan_vals,  sizeof(cyan_vals)},
  {0x05, "Violet",     purple_vals,  sizeof(purple_vals)},
  {0x06, "Magenta",    magenta_vals,  sizeof(magenta_vals)},
  {0x07, "Rose",       pink_vals,  sizeof(pink_vals)},
  {0x08, "Rouge",      red_vals,  sizeof(red_vals)},
  {0x09, "Orange",     orange_vals,  sizeof(orange_vals)},
  {0x0A, "Vert",       green_vals,  sizeof(green_vals)},
  {0x0B, "Favori",     fav_vals,  sizeof(fav_vals)},
  {0x10, "Gradient",   gradient_vals,  sizeof(gradient_vals)},
  {0x11, "Rainbow",    rainbow_vals,  sizeof(rainbow_vals)},
  {0x12, "Parade",     parade_vals,  sizeof(parade_vals)},
  {0x13, "Techno",     techno_vals,  sizeof(techno_vals)},
  {0x14, "Horizon",    horizon_vals,  sizeof(horizon_vals)},
  {0x15, "Hazard",     hazard_vals,  sizeof(hazard_vals)},
  {0x16, "Magical",    magical_vals,  sizeof(magical_vals)},
};

// --- Lookup direct ---
constexpr uint8_t MAX_CODE = 0x16;
static const ColorMap* color_lookup_direct[MAX_CODE + 1] = { nullptr };

inline void init_color_lookup_direct() {
    for (size_t i = 0; i < std::size(color_map); ++i) {
        uint8_t code = color_map[i].code;
        if (code <= MAX_CODE) {
            color_lookup_direct[code] = &color_map[i];
        }
    }
}

// Récupération rapide par code
inline const ColorMap* get_color_fast(uint8_t code) {
    return (code <= MAX_CODE) ? color_lookup_direct[code] : nullptr;
}

// Récupération par nom (recherche linéaire, rarement utilisée)
inline const ColorMap* get_color_by_name(const char* name) {
    for (size_t i = 0; i < std::size(color_map); ++i) {
        if (strcmp(color_map[i].sensor_name, name) == 0) {
            return &color_map[i];
        }
    }
    return nullptr;
}